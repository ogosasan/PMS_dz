/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "main.h"
#include <stdbool.h>
#include <string.h>
char TxBuffer[256]="";
uint16_t adc_buffer[16];
uint8_t adc_index = 0;
uint8_t adc_start_flag = 0;




void TIM2_IRQHandler()
{
  adc_start_flag = 1;
  TIM2->SR &= ~TIM_SR_UIF; // сбросили флаг прерывания (записью нуля в нужный бит)
}

void init_clk(void)
{
  // Enable HSI
  RCC->CR |= RCC_CR_HSION;
  while(!(RCC->CR & RCC_CR_HSIRDY)){};

  // Enable Prefetch Buffer
  FLASH->ACR |= FLASH_ACR_PRFTBE;

  // Flash 2 wait state
  FLASH->ACR &= ~FLASH_ACR_LATENCY;
  FLASH->ACR |= FLASH_ACR_LATENCY_2;

  // HCLK = SYSCLK
  RCC->CFGR |= RCC_CFGR_HPRE_DIV1;

  // PCLK2 = HCLK
  RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;

  // PCLK1 = HCLK
  RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;

  // PLL configuration: PLLCLK = HSI/2 * 16 = 64 MHz
  RCC->CFGR &= ~RCC_CFGR_PLLSRC;
  RCC->CFGR |= RCC_CFGR_PLLMULL16;

  // Enable PLL
  RCC->CR |= RCC_CR_PLLON;

  // Wait till PLL is ready
  while((RCC->CR & RCC_CR_PLLRDY) == 0) {};

  // Select PLL as system clock source
  RCC->CFGR &= ~RCC_CFGR_SW;
  RCC->CFGR |= RCC_CFGR_SW_PLL;

  // Wait till PLL is used as system clock source
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_PLL){};
} // волшебной функцией выставили тактирование на 64 МГц

void init_tim2()
{
  RCC->APB1ENR |= RCC_APB1ENR_TIM2EN; // включаем тактирование таймера
  //64 МГц

  TIM2->PSC = 64000-1; // настроили прескейлер, теперь таймер считает с частотой 1 кГц
  TIM2->ARR = 100;

  TIM2->DIER |= TIM_DIER_UIE; // разрешили прерывание

  TIM2->CR1 |= TIM_CR1_CEN; // включили таймер (запустили счетчик, он начнет считать и пытаться генерировать прерывания, когда дойдет до 1000)


  NVIC_EnableIRQ(TIM2_IRQn); // разрешили прерывание для системы TIM2
  NVIC_SetPriority(TIM2_IRQn, 2); // выставили приоритет
}

void init_usart2()
{
  //pa2 - tx
  //pa3 - rx
  RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_AFIOEN; // тактирование альтернативных функций и А
  RCC->APB1ENR |= RCC_APB1ENR_USART2EN ; // тактирование юарта

  GPIOA->CRL |= GPIO_CRL_MODE2; //настройка порта А, записали в MODE 11
  GPIOA->CRL &= ~GPIO_CRL_CNF2_0; //настройка порта А, записали в CNF .0
  GPIOA->CRL |= GPIO_CRL_CNF2_1; //настройка порта А, записали в CNF 1. (в сумме 10)
  //output push-pull
  //настроить скорость передачи данных:
  //Fck = 32 МГ2, тк в 2 раза меньше чем на АПБ2 - 64/2=32
  //57600
  USART2->BRR = 0x22C; //регистр с целой и дробной частью
  //Baud Rate Register
  USART2->CR1 |= USART_CR1_UE | USART_CR1_RE | USART_CR1_TE | USART_CR1_RXNEIE; // включить юарт, разрешить передачу (включить передатчик), разрешить прием (включить приемник), разрешить прерывание по приему данных

  NVIC_EnableIRQ(USART2_IRQn); // разрешили прерывание для системы USART2
  NVIC_SetPriority(USART2_IRQn, 0); // выставили приоритет
}


void usart2_transmit (char *str)
{
  strcat(str, "\r\n");

  for (uint8_t i=0; i<strlen(str); i++)
  {
    USART2->DR = str[i]; //после этой строчки начнется передача данных
    while((USART2->SR & USART_SR_TC)==0); // ждем пока передача данных завершится, чтобы не начать новую передачу раньше времени
  }//status register, Transmission Complete
}

void init_adc(){
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN | RCC_APB2ENR_ADC1EN;
	GPIOA->CRL &= ~(GPIO_CRL_CNF0 | GPIO_CRL_MODE0);

	ADC1->SMPR2 |= ADC_SMPR2_SMP0;
	ADC1->CR2 |= ADC_CR2_EXTSEL | ADC_CR2_EXTTRIG | ADC_CR2_ADON;
	delay(2);
	ADC1->CR2 |= ADC_CR2_CAL;
	while((ADC1->CR2 & ADC_CR2_CAL)!=0);
}

uint16_t read_adc(uint8_t channel){
	ADC1->SQR3 = channel & (0b11111);
	ADC1->CR2 |= ADC_CR2_SWSTART;
	while((ADC1->SR & ADC_SR_EOC) == 0);
	return ADC1->DR;
}


int main(void)
{
  init_clk();
  init_tim2();
  init_usart2();
  init_adc();
  uint8_t adc_full_flag = 0;
    while(1)
    {

      if(adc_start_flag){
		  uint16_t val = read_adc(0);
		  adc_buffer[adc_index++] = val;
		  if(adc_index >= 16){
			  adc_index = 0;
			  adc_full_flag = 1;
		  }
		  adc_start_flag = 0;
          }
      if(adc_full_flag){
    	  uint32_t sum = 0;
      	  for(int i=0;i<16;i++){
      		  sum += adc_buffer[i];
      	  }
      	  uint16_t average = sum/16;
      	  uint32_t mv = average*3300/0xFFF;
      	  uint16_t integer = mv/1000;
      	  uint16_t fraction = mv%1000;
      	  memset(TxBuffer, 0, sizeof(TxBuffer));
      	  sprintf(TxBuffer, "%u.%03u", integer, fraction);
      	  usart2_transmit(TxBuffer);
      	  adc_full_flag = 0;
      }
    }
}

void delay (uint32_t delay_value)
{
  for (uint32_t i=0; i<delay_value; i++);
}

